# IR 设计

> 本文的有关代码在 [这里](https://github.com/AlmondRyan/Ryntra-Project/tree/master/Compiler/IR)

欢迎来到特别重要的一节！（其实每一节都特别重要，都是强耦合的）

如果说编译器是程序的翻译官，那 IR（Intermediate Representation，中间表示）就是翻译官脑海中的思考语言。它既不是源代码，也不是目标代码，而是一个精心设计的中间形态，承载着各种优化和转换。

在这节中，我们将探讨一个事 —— IR 的设计，而并非 IR 的构建，那是下一章的事。

这一节的定义非常的多，让我们开始吧。

## 两个核心概念 —— SSA 和 GC

在了解我们的 IR 设计之前，必须先来了解一下 SSA（Static Single Assignment，静态单赋值）和 GC（Garbage Collection，垃圾回收）。

### SSA

在传统的编程语言中，变量可以多次赋值，比如说：
```
x = 1
x = x + 2
x = 5
```

在这种代码中，`x` 代表不同的值，取决于程序执行到哪一行，这对数据流分析产生了很大的麻烦。

那么我们引入了 SSA，在 SSA 中：

- 每个变量只能被定义（赋值）一次
- 如果一个逻辑变量需要多次赋值，会把变量重命名为多个不同的版本

那么上面的代码转到 SSA 就是这样：
```
x1 = 1
x2 = x1 + 2
x3 = 5
```

看到了吗？现在每个变量名都唯一对应一个具体的值，这使得定义-使用链（Use-Def Chain）变得特别直接，因为任何地方的变量使用都指向唯一的定义点。

其实 SSA 还有一个更重要的函数 Phi 函数，我们会在控制流部分详细的讲。

### GC

GC（Garbage Collection）是我们的语言运行时的重要组件。IR 的设计需要为 GC 提供足够的信息，比如：哪些变量是对象引用？哪些指令可能触发 GC？这些信息将在代码生成时转化为精确的栈图（StackMap），让 GC 能够安全、准确地回收内存。

## 我们的 IR - Ryntra SSA IR

现在，让我们来看看我们的 IR 具体长什么样。设计目标是：既要能表达高级语言的特性，又要为优化和代码生成提供足够的信息，同时还要考虑实现的复杂度。

### 类型系统

类型系统是 IR 的基础。我们的设计相当细致：

```ebnf
type ::=
        void
        | i1 | i8 | i16 | i32 | i64 | f32 | f64
        | string         // 字符串引用，由 GC 管理
        | class <name>   // 类引用，由 GC 管理
        | struct <name>  // 结构体，值类型
        | array <type>   // 数组引用，由 GC 管理
        | ptr <type>     // 临时内部指针，有严格的生命周期限制
        | fn(<type>*) -> <type>
```

有几点需要特别注意：

- 泛型：每个泛型进入 IR 的时候都会被消除，举个例子：进入的时候是 `List<T>` 其中传入的是 `int`，在 IR 的时候会被识别为 `List<int>`，IR 中不包含泛型参数
- 指针：`ptr <type>` 是一种特殊的指令类型，用于优化连续的字段访问，但是他不可以跨越 SafePoint（可能触发 GC 的点，比如函数调用、对象分配）。如果在这些点之后调用 `ptr`，如果 GC 一发生，对象被移动，指针即刻失效。所以 VM 必须保证 `ptr` 在 SafePoint 之后重新计算。 

### 值系统

我们的 IR 支持两种类型的值：

1. SSA 虚拟寄存器: `%1`, `%a` - 这些是编译器内部使用的临时变量，就像是我们举例子的 `x1`, `x2`
2. 字面量: `1`, `3.14`, `null` - 这些是编译时常量

### 指令系统

我们的指令系统分为几个类别，每个类别都有明确的语义和约束：

#### 纯值运算

> 纯值运算没有副作用

这些指令不产生副作用，可以进行各种优化：
```
add, sub, mul, div, rem  // 算术运算（加减乘除取余）
and, or, xor, shl, shr   // 位运算（与或异或左右移）
cmp [eq|ne|gt|ge|lt|le]  // 比较运算
neg, not                 // 一元运算
cast <type>              // 类型转换
```

#### 内存与对象操作

**所有修改堆内存的操作都隐含写屏障 (Write Barrier)。**

什么是写屏障？就像是在程序中的一段钩子代码，每当应用程序试图修改对象引用（就是写操作）的时候，这段代码自动触发执行。目的是通知 GC：“注意！对象的引用关系发生了变化，请记录或处理这个变化，以保证 GC 的正确性。”

```
// 读取对象字段，如果对象为 null 则触发 Panic
%val = load_field %obj, field_index

// 写入对象字段，如果写入的是引用类型，必须触发写屏障
store_field %obj, field_index, %val

// 数组操作类似，带有边界检查
%val = load_elem %arr, %index
store_elem %arr, %index, %val
```

这里还有一个特殊的指针操作指令：

```
// 用于紧凑的局部操作，但切记：不能跨 SafePoint 使用！
%ptr = gep %base, index...
%val = load %ptr
store %ptr, %val
```

#### 对象管理

所有分配指令都是 SafePoint，可能触发 GC。因此，每个分配点都必须生成 StackMap，记录当前活跃的引用变量。

```
// 分配对象
%obj = new <class_name>

// 分配数组
%arr = new_array <type>, %len
```

#### 函数调用

无论常规调用还是可能抛出异常的调用，都是 SafePoint：

> `unwind` 就是：每次发生异常的时候都会向上退出调用栈，直到找到一个被处理的 `catch` 之类的块，每次退出一层调用栈都要清理一些资源，这个过程就叫做栈展开（Stack Unwinding）

```
// 常规调用
%ret = call @func(%args...)

// 可能抛出异常的调用，需要指定正常和异常分支
%ret = invoke @func(%args...) to label_normal unwind label_unwind
```

#### 5. 控制流 (Loop SafePoints)

对于循环，我们需要在回边（Backedge）处插入 Poll 点，确保长时间运行的循环能够响应 GC 请求：

```
br label                                // 无条件跳转
cond_br %cond, label_true, label_false  // 条件跳转
ret %val                                // 函数返回
```

## 总结

我们的 IR 设计是一个平衡了表达力、优化能力和实现复杂度的产物。它既要能够表达高级语言的所有特性，又要为后续的优化和代码生成提供足够的信息。

在下一章中，我们将具体实现这个 IR 系统，包括如何构建 IR、如何遍历 IR、以及如何进行简单的优化。

记住：好的 IR 设计是编译器成功的一半！