# 语义分析

> 本文的有关代码在 [这里](https://github.com/AlmondRyan/Ryntra-Project/tree/master/Compiler/Semantic)

欢迎来到语义分析部分！我们废话不多说，直接进入正题。

## 错误处理器的实现

在开始写语义分析之前，我们在上一章引入了一个东西不知道你是否注意到 —— `ErrorHandler` 类。如果你没注意到，你可以回头看一下：

> `ErrorHandler::getInstance().makeError("SymbolTable: No scope to define symbol", location);`

这一行。如果你有一些开发经验的话，你可以明显看出来这个是一个单例类（Singleton），也就是全局共享一个实例，特别适用于我们这个错误处理系统。

它主要收集三种错误信息：

- Hint（提示）：类似于 “此处接口的声明是...”，“函数的定义名称是...”，“你是否需要的是...函数” 等
- Warning（警告）：虽然代码可以跑，但是有可能会出现问题导致罢工，比如 “函数调用返回值被舍弃”，“函数已被废除” 等
- Error（错误）：代码彻底罢工了

实现非常的简单，只需要一个类型、一个错误对象、一个处理器即可。我们来一个一个看：

### 错误类型和错误对象

由于我们只有三种错误信息，我们可以通过定义枚举来实现三种错误类型：

```Cpp
enum ErrorType {
    ET_HINT,
    ET_WARNING,
    ET_ERROR
};
```

以及错误对象，我们需要存储该错误信息的描述、类型和对应源代码的位置：

```Cpp
struct ErrorObject {
    ErrorType type;
    std::string description;
    SourceLocation location;

    ErrorObject(const ErrorType type, const SourceLocation _l, std::string desc)
        : type(type), description(std::move(desc)), location(_l) {
    }
};
```

### 错误处理器

错误处理器的系统主要就是一个列表、三个创建函数，实现特别的粗暴：

- 实现单例
- 提供一个接口访问列表
- 创建三个函数用于向列表里推入错误对象

先来看实现单例：

```Cpp
class ErrorHandler {
public:
    static ErrorHandler &getInstance();

    ErrorHandler(const ErrorHandler &) = delete;
    ErrorHandler &operator=(const ErrorHandler &) = delete;
    ErrorHandler(ErrorHandler &&) = delete;
    ErrorHandler &operator=(ErrorHandler &&) = delete;
private:
    ErrorHandler() = default;
};
```

我们这里定义了一个静态方法 `getInstance()`，这样就可以通过 `ErrorHandler::getInstance()` 方式访问那唯一的对象。

并且，我们删除了移动构造函数和拷贝构造函数以确保全局唯一性。

再来看最主要的几个函数：

```Cpp
public:
    // 创建
    void makeWarning(const std::string &desc, SourceLocation location);
    void makeHint(const std::string &desc, SourceLocation location);
    void makeError(const std::string &desc, SourceLocation location);

    // 打印
    void print() const;

    // 获取
    [[nodiscard]] std::vector<ErrorObject> getErrorObjects() const {
        return errorObjects;
    }
private:
    // 列表
    std::vector<ErrorObject> errorObjects;
```

是不是非常的好理解？

## 统一的 Visitor 接口

解决了错误处理器之后，接下来我们来解决继承问题。

我们在 AST 访问章节说过，我们用的是 Acyclic Visitor，也就是继承必须手动写出所有的继承类型。那对于我们这种特殊的需求（必须继承全部节点类型），而且懒人来说，什么东西最简单呢？

那当然是脚本生成！

我们这里利用一个 `.txt` 文件定义所有的节点类型，分别是现有的

```
TypeSpecifierNode
StringLiteralNode
IdentifierNode
FunctionCallNode
....
```

然后用 Python 读取这个来生成一个统一的头文件：

```Python
import sys

def main():
    # 读取命令行参数
    if (len(sys.argv) != 2):
        print("Usage: GenAllNodesVisitor.py <outputFile>")
        sys.exit(1)

    outputPath = sys.argv[1]

    # 打开节点列表
    with open('NodesList.txt', 'r', encoding='utf-8') as f:
        node_names = [line.strip() for line in f if line.strip()]

    if not node_names:
        print("Warning: NodesList.txt is empty or cannot be properly read")
        return

    # 生成节点继承者
    inheritance_lines = ["public IVisitor"]
    for name in node_names:
        inheritance_lines.append(f"public Visitor<{name}>")

    inheritance = ",\n".join(inheritance_lines)
    
    # 生成 visit() 函数
    visit_methods = []
    for name in node_names:
        visit_methods.append(f"virtual void visit({name} &node) override {{}}")

    visit_block = "\n".join(visit_methods)

    # 生成代码
    code = f"""// Generated by GenAllNodesVisitor.py, DO NOT EDIT!
#pragma once
#include "ASTVisitor.h"
#include "ASTNodes.h"
namespace Ryntra::Compiler {{
class AllNodesVisitor : {inheritance}
{{
public:
virtual ~AllNodesVisitor() = default;
{visit_block}
}};
}}
"""

    # 写出代码
    with open(outputPath, 'w', encoding='utf-8') as out_file:
        out_file.write(code)

if __name__ == '__main__':
    main()
```

当调用的时候，它会自动生成一个统一的 C++ 接口，省去了我们一个一个写的难题。

## 工作原理

语义分析器的核心工作就是遍历 AST，检查代码是否符合语言的规则。它继承自 `AllNodesVisitor`，并持有一个我们上一章讲过的 `SymbolTable`。

```Cpp
class SemanticAnalyzer : public AllNodesVisitor {
public:
    void analyze(const std::shared_ptr<IASTNode>& root);
    // ... visit methods ...
private:
    SymbolTable symbolTable;
};
```

其中，`analyze()` 方法是我们统一的入口，在其中调用 `root->accept(*this)` 来开始遍历 AST，就像我们 AST 访问那一章给出的例子一样。

## 分析源文件

语义分析通常需要两次甚至多次遍历，按照两次遍历来说，第一次填充符号表，第二次才真正的进行语义检查。我们也是按照这种思路来做的。

### 分析程序入口

在 `visit(ProgramNode)` 中，我们使用了两遍扫描逻辑，分别是：

**第一遍——注册所有函数**

我们遍历所有的函数定义，把他们的名字、返回类型等一一填充到符号表中，就像这样：

```Cpp
for (const auto &func : node.getFunctions()) {
    std::vector<std::string> paramTypes; 
    
    // 这里 funcName 第一遍得到的是 Identifier，第二遍才得到 string 类型的名字
    auto funcName = func->getName()->getName();
    auto returnType = func->getReturnType()->getName();
    
    symbolTable.define(std::make_shared<FunctionSymbol>(funcName, returnType, paramTypes), func->getLocation());
}
```

然后，检查所有注册的函数中是否有 `main()` 入口函数，如果没有即报错：

```Cpp
// 查找符号
auto mainSym = symbolTable.resolve("main");

// 如果符号不存在
if (!mainSym) {
    ErrorHandler::getInstance().makeError("Semantic Error: 'main' function is not defined.", node.getLocation());
    return;
}

// 如果符号转不了函数节点
auto mainFuncSym = std::dynamic_pointer_cast<FunctionSymbol>(mainSym);
if (!mainFuncSym) {
    ErrorHandler::getInstance().makeError("Semantic Error: 'main' is not a function.", node.getLocation());
    return;
}

// 如果符号类型不是 int
if (mainFuncSym->getReturnType() != "int") {
    ErrorHandler::getInstance().makeError("Semantic Error: 'main' function must return 'int'.", node.getLocation());
}
```

**第二遍——真正的语义分析**

还是那句话，由于是函数组成的程序，我们依旧采取：

```Cpp
for (const auto &func : node.getFunctions()) {
    func->accept(*this);
}
```

的模式。

### 分析字符串字面量

由于字符串字面量内部没有任何需要检查的东西（至少，转义字符会在 AST 生成的时候就转成对应的转义字符），所以我们这里留空。

### 分析标识符

`visit(IdentifierNode)` 也是空的。但在真正的编译器中，这里是用来检查变量是否已定义的关键地方。比如你写了 `a = 10`，编译器得先去符号表里查查 `a` 是谁，如果查不到，就得报错“未声明的标识符”。

### 分析表达式

这里主要指的是函数调用表达式 `visit(FunctionCallNode)`。这是语义分析的一个重头戏。

我们区分了 **内置函数** 和 **用户自定义函数**。

内置函数检查（以 `__builtin_` 开头）：
我们不仅要检查函数是否存在，还要严格检查参数的数量和类型。比如 `__builtin_print` 期望一个字符串参数，如果你传了个数字，这里就会报错。

```Cpp
if (args.size() != expectedParams.size()) {
    ErrorHandler::getInstance().makeError("Expects " + ... + " arguments, but got " + ...);
}

// 检查参数类型
for (size_t i = 0; i < args.size(); ++i) {
    if (expectedParams[i] == "string") {
        if (!std::dynamic_pointer_cast<StringLiteralNode>(args[i])) {
             ErrorHandler::getInstance().makeError("Argument ... must be a string literal.");
        }
    }
}
```

用户函数检查：
对于用户定义的函数，目前我们只检查了它是否在符号表中存在。我们暂时不支持声明自定义函数。

### 分析语句

`visit(ExpressionStatementNode)` 负责处理表达式语句（比如单独的一行函数调用）。它的逻辑很简单，就是把内部的表达式拿出来继续分析。

```Cpp
void SemanticAnalyzer::visit(ExpressionStatementNode &node) {
    node.getExpression()->accept(*this);
}
```

### 分析语句块

`visit(BlockNode)` 负责处理 `{ ... }` 包裹的代码块。它会遍历块内的所有语句并逐个分析。

```Cpp
void SemanticAnalyzer::visit(BlockNode &node) {
    symbolTable.enterScope();
    for (const auto &stmt : node.getStatements()) {
        stmt->accept(*this);
    }
    symbolTable.exitScope();
}
```

别忘了，进入大括号之前要推入一个新的作用域，离开的时候弹出。

## 小结

到目前为止，我们的语义分析器已经能做不少事情了：

1.  它能认出 `main` 函数，并确保它符合规范。
2.  它能处理函数的定义和调用，支持前向引用。
3.  它能对内置函数的参数进行严格的类型检查。
4.  它能利用 `ErrorHandler` 优雅地报告错误，而不是直接崩溃。

接下来，就是最让人感到开心的两部分——IR和VM。